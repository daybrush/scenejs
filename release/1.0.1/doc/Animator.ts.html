<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Animator.ts - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/daybrush.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="description" content="Animator.ts - Documentation"/>

</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h2 class="custom"><a href="https://github.com/daybrush/scenejs" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h2 class="custom"><a href="https://daybrush.com/scenejs/features.html" target="_blank" class="menu-item" id="features" >Features</a></h2><div class="search"><div class="input-area"><input type="text"/></div><button></button></div><ul class="classes"><li file="scene" class="parent"><a href="Scene.html">Scene</a><h4><a href="Scene.html#static members">Static Members</a></h4><ul class='static members'><li data-type='member'><a href="Scene.html#.EVENTS">EVENTS</a></li><li data-type='member'><a href="Scene.html#.OPTIONS">OPTIONS</a></li><li data-type='member'><a href="Scene.html#.VERSION">VERSION</a></li></ul><h4><a href="Scene.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="Scene.html#end">end</a></li><li data-type='method'><a href="Scene.html#exportCSS">exportCSS</a></li><li data-type='method'><a href="Scene.html#finish">finish</a></li><li data-type='method'><a href="Scene.html#forEach">forEach</a></li><li data-type='method'><a href="Scene.html#getActiveDuration">getActiveDuration</a></li><li data-type='method'><a href="Scene.html#getDelay">getDelay</a></li><li data-type='method'><a href="Scene.html#getDirection">getDirection</a></li><li data-type='method'><a href="Scene.html#getDuration">getDuration</a></li><li data-type='method'><a href="Scene.html#getEasing">getEasing</a></li><li data-type='method'><a href="Scene.html#getEasingName">getEasingName</a></li><li data-type='method'><a href="Scene.html#getFillMode">getFillMode</a></li><li data-type='method'><a href="Scene.html#getId">getId</a></li><li data-type='method'><a href="Scene.html#getItem">getItem</a></li><li data-type='method'><a href="Scene.html#getIterationCount">getIterationCount</a></li><li data-type='method'><a href="Scene.html#getIterationTime">getIterationTime</a></li><li data-type='method'><a href="Scene.html#getPlaySpeed">getPlaySpeed</a></li><li data-type='method'><a href="Scene.html#getPlayState">getPlayState</a></li><li data-type='method'><a href="Scene.html#getTime">getTime</a></li><li data-type='method'><a href="Scene.html#getTotalDuration">getTotalDuration</a></li><li data-type='method'><a href="Scene.html#isDelay">isDelay</a></li><li data-type='method'><a href="Scene.html#isEnded">isEnded</a></li><li data-type='method'><a href="Scene.html#isPaused">isPaused</a></li><li data-type='method'><a href="Scene.html#newItem">newItem</a></li><li data-type='method'><a href="Scene.html#off">off</a></li><li data-type='method'><a href="Scene.html#on">on</a></li><li data-type='method'><a href="Scene.html#pause">pause</a></li><li data-type='method'><a href="Scene.html#play">play</a></li><li data-type='method'><a href="Scene.html#playCSS">playCSS</a></li><li data-type='method'><a href="Scene.html#removeItem">removeItem</a></li><li data-type='method'><a href="Scene.html#setDelay">setDelay</a></li><li data-type='method'><a href="Scene.html#setDirection">setDirection</a></li><li data-type='method'><a href="Scene.html#setDuration">setDuration</a></li><li data-type='method'><a href="Scene.html#setEasing">setEasing</a></li><li data-type='method'><a href="Scene.html#setFillMode">setFillMode</a></li><li data-type='method'><a href="Scene.html#setId">setId</a></li><li data-type='method'><a href="Scene.html#setItem">setItem</a></li><li data-type='method'><a href="Scene.html#setIterationCount">setIterationCount</a></li><li data-type='method'><a href="Scene.html#setOptions">setOptions</a></li><li data-type='method'><a href="Scene.html#setPlaySpeed">setPlaySpeed</a></li><li data-type='method'><a href="Scene.html#setPlayState">setPlayState</a></li><li data-type='method'><a href="Scene.html#setTime">setTime</a></li><li data-type='method'><a href="Scene.html#trigger">trigger</a></li></ul><h4><a href="Scene.html#events">Events</a></h4><ul class='events'><li data-type='event'><a href="Scene.html#event:animate">animate</a></li><li data-type='event'><a href="Scene.html#event:ended">ended</a></li><li data-type='event'><a href="Scene.html#event:iteration">iteration</a></li><li data-type='event'><a href="Scene.html#event:paused">paused</a></li><li data-type='event'><a href="Scene.html#event:play">play</a></li><li data-type='event'><a href="Scene.html#event:timeupdate">timeupdate</a></li></ul></li><li file="animator" class="parent"><a href="Animator.html">Animator</a><h4><a href="Animator.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="Animator.html#end">end</a></li><li data-type='method'><a href="Animator.html#finish">finish</a></li><li data-type='method'><a href="Animator.html#getActiveDuration">getActiveDuration</a></li><li data-type='method'><a href="Animator.html#getDelay">getDelay</a></li><li data-type='method'><a href="Animator.html#getDirection">getDirection</a></li><li data-type='method'><a href="Animator.html#getDuration">getDuration</a></li><li data-type='method'><a href="Animator.html#getEasing">getEasing</a></li><li data-type='method'><a href="Animator.html#getEasingName">getEasingName</a></li><li data-type='method'><a href="Animator.html#getFillMode">getFillMode</a></li><li data-type='method'><a href="Animator.html#getId">getId</a></li><li data-type='method'><a href="Animator.html#getIterationCount">getIterationCount</a></li><li data-type='method'><a href="Animator.html#getIterationTime">getIterationTime</a></li><li data-type='method'><a href="Animator.html#getPlaySpeed">getPlaySpeed</a></li><li data-type='method'><a href="Animator.html#getPlayState">getPlayState</a></li><li data-type='method'><a href="Animator.html#getTime">getTime</a></li><li data-type='method'><a href="Animator.html#getTotalDuration">getTotalDuration</a></li><li data-type='method'><a href="Animator.html#isDelay">isDelay</a></li><li data-type='method'><a href="Animator.html#isEnded">isEnded</a></li><li data-type='method'><a href="Animator.html#isPaused">isPaused</a></li><li data-type='method'><a href="Animator.html#off">off</a></li><li data-type='method'><a href="Animator.html#on">on</a></li><li data-type='method'><a href="Animator.html#pause">pause</a></li><li data-type='method'><a href="Animator.html#play">play</a></li><li data-type='method'><a href="Animator.html#setDelay">setDelay</a></li><li data-type='method'><a href="Animator.html#setDirection">setDirection</a></li><li data-type='method'><a href="Animator.html#setDuration">setDuration</a></li><li data-type='method'><a href="Animator.html#setEasing">setEasing</a></li><li data-type='method'><a href="Animator.html#setFillMode">setFillMode</a></li><li data-type='method'><a href="Animator.html#setId">setId</a></li><li data-type='method'><a href="Animator.html#setIterationCount">setIterationCount</a></li><li data-type='method'><a href="Animator.html#setOptions">setOptions</a></li><li data-type='method'><a href="Animator.html#setPlaySpeed">setPlaySpeed</a></li><li data-type='method'><a href="Animator.html#setPlayState">setPlayState</a></li><li data-type='method'><a href="Animator.html#setTime">setTime</a></li><li data-type='method'><a href="Animator.html#trigger">trigger</a></li></ul><h4><a href="Animator.html#events">Events</a></h4><ul class='events'><li data-type='event'><a href="Animator.html#event:ended">ended</a></li><li data-type='event'><a href="Animator.html#event:iteration">iteration</a></li><li data-type='event'><a href="Animator.html#event:paused">paused</a></li><li data-type='event'><a href="Animator.html#event:play">play</a></li><li data-type='event'><a href="Animator.html#event:timeupdate">timeupdate</a></li></ul></li><li file="eventtrigger" class="parent"><a href="EventTrigger.html">EventTrigger</a><h4><a href="EventTrigger.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="EventTrigger.html#off">off</a></li><li data-type='method'><a href="EventTrigger.html#on">on</a></li><li data-type='method'><a href="EventTrigger.html#trigger">trigger</a></li></ul></li><li file="frame" class="parent"><a href="Frame.html">Frame</a><h4><a href="Frame.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="Frame.html#clone">clone</a></li><li data-type='method'><a href="Frame.html#get">get</a></li><li data-type='method'><a href="Frame.html#getNames">getNames</a></li><li data-type='method'><a href="Frame.html#has">has</a></li><li data-type='method'><a href="Frame.html#merge">merge</a></li><li data-type='method'><a href="Frame.html#remove">remove</a></li><li data-type='method'><a href="Frame.html#set">set</a></li><li data-type='method'><a href="Frame.html#toCSS">toCSS</a></li><li data-type='method'><a href="Frame.html#toCSSObject">toCSSObject</a></li></ul></li><li file="propertyobject" class="parent"><a href="PropertyObject.html">PropertyObject</a><h4><a href="PropertyObject.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="PropertyObject.html#clone">clone</a></li><li data-type='method'><a href="PropertyObject.html#forEach">forEach</a></li><li data-type='method'><a href="PropertyObject.html#get">get</a></li><li data-type='method'><a href="PropertyObject.html#join">join</a></li><li data-type='method'><a href="PropertyObject.html#set">set</a></li><li data-type='method'><a href="PropertyObject.html#size">size</a></li><li data-type='method'><a href="PropertyObject.html#toValue">toValue</a></li></ul></li><li file="sceneitem" class="parent"><a href="SceneItem.html">SceneItem</a><h4><a href="SceneItem.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="SceneItem.html#append">append</a></li><li data-type='method'><a href="SceneItem.html#clone">clone</a></li><li data-type='method'><a href="SceneItem.html#end">end</a></li><li data-type='method'><a href="SceneItem.html#exportCSS">exportCSS</a></li><li data-type='method'><a href="SceneItem.html#finish">finish</a></li><li data-type='method'><a href="SceneItem.html#forEach">forEach</a></li><li data-type='method'><a href="SceneItem.html#get">get</a></li><li data-type='method'><a href="SceneItem.html#getActiveDuration">getActiveDuration</a></li><li data-type='method'><a href="SceneItem.html#getDelay">getDelay</a></li><li data-type='method'><a href="SceneItem.html#getDirection">getDirection</a></li><li data-type='method'><a href="SceneItem.html#getDuration">getDuration</a></li><li data-type='method'><a href="SceneItem.html#getEasing">getEasing</a></li><li data-type='method'><a href="SceneItem.html#getEasingName">getEasingName</a></li><li data-type='method'><a href="SceneItem.html#getElements">getElements</a></li><li data-type='method'><a href="SceneItem.html#getFillMode">getFillMode</a></li><li data-type='method'><a href="SceneItem.html#getFrame">getFrame</a></li><li data-type='method'><a href="SceneItem.html#getId">getId</a></li><li data-type='method'><a href="SceneItem.html#getIterationCount">getIterationCount</a></li><li data-type='method'><a href="SceneItem.html#getIterationTime">getIterationTime</a></li><li data-type='method'><a href="SceneItem.html#getNowFrame">getNowFrame</a></li><li data-type='method'><a href="SceneItem.html#getPlaySpeed">getPlaySpeed</a></li><li data-type='method'><a href="SceneItem.html#getPlayState">getPlayState</a></li><li data-type='method'><a href="SceneItem.html#getTime">getTime</a></li><li data-type='method'><a href="SceneItem.html#getTotalDuration">getTotalDuration</a></li><li data-type='method'><a href="SceneItem.html#hasFrame">hasFrame</a></li><li data-type='method'><a href="SceneItem.html#hasName">hasName</a></li><li data-type='method'><a href="SceneItem.html#isDelay">isDelay</a></li><li data-type='method'><a href="SceneItem.html#isEnded">isEnded</a></li><li data-type='method'><a href="SceneItem.html#isPaused">isPaused</a></li><li data-type='method'><a href="SceneItem.html#mergeFrame">mergeFrame</a></li><li data-type='method'><a href="SceneItem.html#newFrame">newFrame</a></li><li data-type='method'><a href="SceneItem.html#off">off</a></li><li data-type='method'><a href="SceneItem.html#on">on</a></li><li data-type='method'><a href="SceneItem.html#pause">pause</a></li><li data-type='method'><a href="SceneItem.html#play">play</a></li><li data-type='method'><a href="SceneItem.html#playCSS">playCSS</a></li><li data-type='method'><a href="SceneItem.html#prepend">prepend</a></li><li data-type='method'><a href="SceneItem.html#remove">remove</a></li><li data-type='method'><a href="SceneItem.html#removeFrame">removeFrame</a></li><li data-type='method'><a href="SceneItem.html#set">set</a></li><li data-type='method'><a href="SceneItem.html#setCSS">setCSS</a></li><li data-type='method'><a href="SceneItem.html#setDelay">setDelay</a></li><li data-type='method'><a href="SceneItem.html#setDirection">setDirection</a></li><li data-type='method'><a href="SceneItem.html#setDuration">setDuration</a></li><li data-type='method'><a href="SceneItem.html#setEasing">setEasing</a></li><li data-type='method'><a href="SceneItem.html#setElement">setElement</a></li><li data-type='method'><a href="SceneItem.html#setElements">setElements</a></li><li data-type='method'><a href="SceneItem.html#setFillMode">setFillMode</a></li><li data-type='method'><a href="SceneItem.html#setFrame">setFrame</a></li><li data-type='method'><a href="SceneItem.html#setId">setId</a></li><li data-type='method'><a href="SceneItem.html#setIterationCount">setIterationCount</a></li><li data-type='method'><a href="SceneItem.html#setOptions">setOptions</a></li><li data-type='method'><a href="SceneItem.html#setPlaySpeed">setPlaySpeed</a></li><li data-type='method'><a href="SceneItem.html#setPlayState">setPlayState</a></li><li data-type='method'><a href="SceneItem.html#setSelector">setSelector</a></li><li data-type='method'><a href="SceneItem.html#setTime">setTime</a></li><li data-type='method'><a href="SceneItem.html#size">size</a></li><li data-type='method'><a href="SceneItem.html#toObject">toObject</a></li><li data-type='method'><a href="SceneItem.html#trigger">trigger</a></li><li data-type='method'><a href="SceneItem.html#unshift">unshift</a></li><li data-type='method'><a href="SceneItem.html#update">update</a></li></ul><h4><a href="SceneItem.html#events">Events</a></h4><ul class='events'><li data-type='event'><a href="SceneItem.html#event:animate">animate</a></li><li data-type='event'><a href="SceneItem.html#event:ended">ended</a></li><li data-type='event'><a href="SceneItem.html#event:iteration">iteration</a></li><li data-type='event'><a href="SceneItem.html#event:paused">paused</a></li><li data-type='event'><a href="SceneItem.html#event:play">play</a></li><li data-type='event'><a href="SceneItem.html#event:timeupdate">timeupdate</a></li></ul></li></ul><ul class="namespaces"><li file="easing" class="parent"><a href="easing.html">easing</a><h4><a href="easing.html#static methods">Static Methods</a></h4><ul class='static methods'><li data-type='method'><a href="easing.html#.bezier">bezier</a></li><li data-type='method'><a href="easing.html#.steps">steps</a></li></ul><h4><a href="easing.html#static members">Static Members</a></h4><ul class='static members'><li data-type='member'><a href="easing.html#.EASE">EASE</a></li><li data-type='member'><a href="easing.html#.EASE_IN">EASE_IN</a></li><li data-type='member'><a href="easing.html#.EASE_IN_OUT">EASE_IN_OUT</a></li><li data-type='member'><a href="easing.html#.EASE_OUT">EASE_OUT</a></li><li data-type='member'><a href="easing.html#.LINEAR">LINEAR</a></li><li data-type='member'><a href="easing.html#.STEP_END">STEP_END</a></li><li data-type='member'><a href="easing.html#.STEP_START">STEP_START</a></li></ul></li></ul><ul class="global"><li file="global"  class="parent"><a href="global.html">Global</a><h4><a href="global.html#type definitions">Type Definitions</a></h4><ul class='type definitions'><li data-type='typedef'><a href="global.html#AnimateElement">AnimateElement</a></li><li data-type='typedef'><a href="global.html#AnimatorOptions">AnimatorOptions</a></li><li data-type='typedef'><a href="global.html#AnimatorState">AnimatorState</a></li><li data-type='typedef'><a href="global.html#AnimatorState">AnimatorState</a></li><li data-type='typedef'><a href="global.html#CallbackType">CallbackType</a></li><li data-type='typedef'><a href="global.html#DirectionType">DirectionType</a></li><li data-type='typedef'><a href="global.html#EasingFunction">EasingFunction</a></li><li data-type='typedef'><a href="global.html#EasingType">EasingType</a></li><li data-type='typedef'><a href="global.html#ElementsType">ElementsType</a></li><li data-type='typedef'><a href="global.html#EventParameter">EventParameter</a></li><li data-type='typedef'><a href="global.html#EventType">EventType</a></li><li data-type='typedef'><a href="global.html#FillModeType">FillModeType</a></li><li data-type='typedef'><a href="global.html#IterationCountType">IterationCountType</a></li><li data-type='typedef'><a href="global.html#NameType">NameType</a></li><li data-type='typedef'><a href="global.html#OptionType">OptionType</a></li><li data-type='typedef'><a href="global.html#PlayCondition">PlayCondition</a></li><li data-type='typedef'><a href="global.html#PlayStateType">PlayStateType</a></li><li data-type='typedef'><a href="global.html#PropertyObjectState">PropertyObjectState</a></li><li data-type='typedef'><a href="global.html#Role">Role</a></li><li data-type='typedef'><a href="global.html#RoleObject">RoleObject</a></li><li data-type='typedef'><a href="global.html#SceneItemOptions">SceneItemOptions</a></li><li data-type='typedef'><a href="global.html#SceneItemState">SceneItemState</a></li><li data-type='typedef'><a href="global.html#SceneOptions">SceneOptions</a></li><li data-type='typedef'><a href="global.html#SceneState">SceneState</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">Animator.ts</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
    THRESHOLD,
    ALTERNATE, ALTERNATE_REVERSE, REVERSE, INFINITE, NORMAL,
    ITERATION_COUNT, DELAY, FILL_MODE, DIRECTION, PLAY_SPEED,
    DURATION, EASING, ITERATION_TIME, EASING_NAME, PAUSED,
    RUNNING, PLAY, TIMEUPDATE, ENDED, PLAY_STATE, PREV_TIME, TICK_TIME, CURRENT_TIME, ITERATION, OPTIONS, EASINGS
} from "./consts";
import EventTrigger from "./EventTrigger";
import { bezier, steps } from "./easing";
import { toFixed } from "./utils";
import { splitUnit, isString, camelize, requestAnimationFrame, isArray, cancelAnimationFrame } from "@daybrush/utils";
import {
    IterationCountType, DirectionType, AnimatorState,
    EasingFunction, FillModeType, PlayStateType, EasingType, AnimatorOptions,
} from "./types";
import { toPropertyObject } from "./utils/property";

function GetterSetter&lt;T extends new (...args: any[]) => {}>(
    getter: string[], setter: string[], parent: string) {
    return (constructor: T) => {
        const prototype = constructor.prototype;

        getter.forEach(name => {
            prototype[camelize(`get ${name}`)] = function() {
                return this[parent][name];
            };
        });
        setter.forEach(name => {
            prototype[camelize(`set ${name}`)] = function(value: any) {
                this[parent][name] = value;
                return this;
            };
        });
    };
}
export function isDirectionReverse(iteration: number, iteraiontCount: IterationCountType, direction: DirectionType) {
    if (direction === REVERSE) {
        return true;
    } else if (iteraiontCount !== INFINITE &amp;&amp; iteration === iteraiontCount &amp;&amp; iteraiontCount % 1 === 0) {
        return direction === (iteration % 2 >= 1 ? ALTERNATE_REVERSE : ALTERNATE);
    }
    return direction === (iteration % 2 >= 1 ? ALTERNATE : ALTERNATE_REVERSE);
}
/**
* @typedef {Object} AnimatorState The Animator options. Properties used in css animation.
* @property {number} [duration] The duration property defines how long an animation should take to complete one cycle.
* @property {"none"|"forwards"|"backwards"|"both"} [fillMode] The fillMode property specifies a style for the element when the animation is not playing (before it starts, after it ends, or both).
* @property {"infinite"|number} [iterationCount] The iterationCount property specifies the number of times an animation should be played.
* @property {array|function} [easing] The easing(timing-function) specifies the speed curve of an animation.
* @property {number} [delay] The delay property specifies a delay for the start of an animation.
* @property {"normal"|"reverse"|"alternate"|"alternate-reverse"} [direction] The direction property defines whether an animation should be played forwards, backwards or in alternate cycles.
*/

const setters = ["id", ITERATION_COUNT, DELAY, FILL_MODE,
    DIRECTION, PLAY_SPEED, DURATION, PLAY_SPEED, ITERATION_TIME, PLAY_STATE];
const getters = [...setters, EASING, EASING_NAME];

/**
* play video, animation, the others
* @extends EventTrigger
* @see {@link https://www.w3schools.com/css/css3_animations.asp|CSS3 Animation}
*/
@GetterSetter(getters, setters, "state")
class Animator
    &lt;T extends AnimatorOptions = AnimatorOptions, U extends AnimatorState = AnimatorState> extends EventTrigger {
    public state: U;
    private timerId: number = 0;

    /**
     * @param - animator's options
     * @example
  const animator = new Animator({
      delay: 2,
      diretion: "alternate",
      duration: 2,
      fillMode: "forwards",
      iterationCount: 3,
      easing: Scene.easing.EASE,
  });
     */
    constructor(options?: Partial&lt;T &amp; AnimatorOptions>) {
        super();
        this.state = {
            id: "",
            easing: 0,
            easingName: "linear",
            iterationCount: 1,
            delay: 0,
            fillMode: "forwards",
            direction: NORMAL,
            playSpeed: 1,
            currentTime: 0,
            iterationTime: -1,
            iteration: 0,
            tickTime: 0,
            prevTime: 0,
            playState: PAUSED,
            duration: 0,
        } as U;
        this.setOptions(options);
    }
    /**
      * set animator's easing.
      * @param curverArray - The speed curve of an animation.
      * @return {Animator} An instance itself.
      * @example
  animator.({
      delay: 2,
      diretion: "alternate",
      duration: 2,
      fillMode: "forwards",
      iterationCount: 3,
      easing: Scene.easing.EASE,
  });
      */
    public setEasing(curveArray: string | number[] | EasingFunction): this {
        let easing: EasingFunction;

        if (isString(curveArray)) {
            if (curveArray in EASINGS) {
                easing = EASINGS[curveArray];
            } else {
                const obj = toPropertyObject(curveArray);

                if (isString(obj)) {
                    return this;
                } else {
                    if (obj.model === "cubic-bezier") {
                        curveArray = obj.value.map(v => parseFloat(v));
                        easing = bezier(curveArray[0], curveArray[1], curveArray[2], curveArray[3]);
                    } else if (obj.model === "steps") {
                        easing = steps(parseFloat(obj.value[0]), obj.value[1]);
                    } else {
                        return this;
                    }
                }
            }
        } else if (isArray(curveArray)) {
            easing = bezier(curveArray[0], curveArray[1], curveArray[2], curveArray[3]);
        } else {
            easing = curveArray;
        }
        const easingName = easing[EASING_NAME] || "linear";

        const state = this.state;

        state[EASING] = easing;
        state[EASING_NAME] = easingName;
        return this;
    }
    /**
      * set animator's options.
      * @see {@link https://www.w3schools.com/css/css3_animations.asp|CSS3 Animation}
      * @param - animator's options
      * @return {Animator} An instance itself.
      * @example
  animator.({
      delay: 2,
      diretion: "alternate",
      duration: 2,
      fillMode: "forwards",
      iterationCount: 3,
      easing: Scene.eaasing.EASE,
  });
      */
    public setOptions(options: Partial&lt;AnimatorOptions> = {}): this {
        for (const name in options) {
            const value = options[name];

            if (name === EASING) {
                this.setEasing(value);
                continue;
            } else if (name === DURATION) {
                value &amp;&amp; this.setDuration(value);
                continue;
            }
            if (OPTIONS.indexOf(name as any) > -1) {
                this.state[name] = value;
            }
        }

        return this;
    }
    /**
      * Get the animator's total duration including delay
      * @return {number} Total duration
      * @example
  animator.getTotalDuration();
      */
    public getTotalDuration(): number {
        return this.getActiveDuration(true);
    }
    /**
      * Get the animator's total duration excluding delay
      * @return {number} Total duration excluding delay
      * @example
  animator.getActiveDuration();
      */
    public getActiveDuration(delay?: boolean): number {
        const state = this.state;
        const count = state[ITERATION_COUNT];
        if (count === INFINITE) {
            return Infinity;
        }
        return (delay ? state[DELAY] : 0) + this.getDuration() * count;
    }
    /**
      * Check if the animator has reached the end.
      * @return {boolean} ended
      * @example
  animator.isEnded(); // true or false
      */
    public isEnded(): boolean {
        if (this.state[TICK_TIME] === 0 &amp;&amp; this.state[PLAY_STATE] === PAUSED) {
            return true;
        } else if (this.getTime() &lt; this.getActiveDuration()) {
            return false;
        }
        return true;
    }
    /**
      *Check if the animator is paused:
      * @return {boolean} paused
      * @example
  animator.isPaused(); // true or false
      */
    public isPaused(): boolean {
        return this.state[PLAY_STATE] === PAUSED;
    }
    public start(delay: number = this.state[DELAY]): boolean {
        const state = this.state;

        state[PLAY_STATE] = RUNNING;
        if (state[TICK_TIME] >= delay) {
            /**
             * This event is fired when play animator.
             * @event Animator#play
             */
            this.trigger(PLAY);
            return true;
        }
        return false;
    }
    /**
      * play animator
      * @return {Animator} An instance itself.
      */
    public play(toTime?: number) {
        const state = this.state;
        const delay = state[DELAY];
        const currentTime = this.getTime();

        state[PLAY_STATE] = RUNNING;

        if (this.isEnded() &amp;&amp; (currentTime === 0 || currentTime >= this.getActiveDuration())) {
            this.setTime(-delay, true);
        }
        state[TICK_TIME] = this.getTime();

        this.timerId = requestAnimationFrame((time: number) => {
            state[PREV_TIME] = time;
            this.tick(time, toTime);
        });
        this.start();
        return this;
    }
    /**
      * pause animator
      * @return {Animator} An instance itself.
      */
    public pause(): this {
        const state = this.state;

        if (state[PLAY_STATE] !== PAUSED) {
            state[PLAY_STATE] = PAUSED;
            /**
             * This event is fired when animator is paused.
             * @event Animator#paused
             */
            this.trigger(PAUSED);
        }
        cancelAnimationFrame(this.timerId);
        return this;
    }
    /**
       * end animator
       * @return {Animator} An instance itself.
      */
    public finish() {
        this.setTime(0);
        this.state[TICK_TIME] = 0;
        this.end();
        return this;
    }
    /**
       * end animator
       * @return {Animator} An instance itself.
      */
    public end() {
        this.pause();
        /**
             * This event is fired when animator is ended.
             * @event Animator#ended
             */
        this.trigger(ENDED);
        return this;
    }
    /**
      * set currentTime
      * @param {Number|String} time - currentTime
      * @return {Animator} An instance itself.
      * @example

  animator.setTime("from"); // 0
  animator.setTime("to"); // 100%
  animator.setTime("50%");
  animator.setTime(10);
  animator.getTime() // 10
      */
    public setTime(time: number | string, isTick?: boolean, isParent?: boolean) {
        const activeDuration = this.getActiveDuration();
        const state = this.state;
        const prevTime = state[TICK_TIME];
        const delay = state[DELAY];
        let currentTime = isTick ? (time as number) : this.getUnitTime(time);

        state[TICK_TIME] = delay + currentTime;
        if (currentTime &lt; 0) {
            currentTime = 0;
        } else if (currentTime > activeDuration) {
            currentTime = activeDuration;
        }
        state[CURRENT_TIME] = currentTime;
        this.calculate();

        if (isTick &amp;&amp; !isParent) {
            const tickTime = state[TICK_TIME];

            if (prevTime &lt; delay &amp;&amp; time >= 0) {
                this.start(0);
            }
            if (tickTime &lt; prevTime || this.isEnded()) {
                this.end();
                return;
            }
        }
        if (this.isDelay()) {
            return this;
        }
        /**
             * This event is fired when the animator updates the time.
             * @event Animator#timeupdate
             * @param {Object} param The object of data to be sent to an event.
             * @param {Number} param.currentTime The total time that the animator is running.
             * @param {Number} param.time The iteration time during duration that the animator is running.
             * @param {Number} param.iterationCount The iteration count that the animator is running.
             */
        this.trigger(TIMEUPDATE, {
            currentTime,
            time: this.getIterationTime(),
            iterationCount: state[ITERATION],
        });

        return this;
    }
    /**
      * Get the animator's current time
      * @return {number} current time
      * @example
  animator.getTime();
      */
    public getTime(): number {
        return this.state[CURRENT_TIME];
    }
    public getUnitTime(time: string | number) {
        if (isString(time)) {
            const duration = this.getDuration() || 100;

            if (time === "from") {
                return 0;
            } else if (time === "to") {
                return duration;
            }
            const { unit, value } = splitUnit(time);

            if (unit === "%") {
                !this.getDuration() &amp;&amp; (this.setDuration(duration));
                return toFixed(parseFloat(time) / 100 * duration);
            } else if (unit === ">") {
                return value + THRESHOLD;
            } else {
                return value;
            }
        } else {
            return toFixed(time);
        }
    }
    /**
       * Check if the current state of animator is delayed.
       * @return {boolean} check delay state
       */
    public isDelay() {
        const state = this.state;
        const delay = state[DELAY];
        const tickTime = state[TICK_TIME];

        return delay > 0 &amp;&amp; (tickTime &lt; delay);
    }
    public setIteration(iterationCount: number): this {
        const state = this.state;
        const passIterationCount = Math.floor(iterationCount);
        const maxIterationCount = state[ITERATION_COUNT] === INFINITE ? Infinity : state[ITERATION_COUNT];

        if (state[ITERATION] &lt; passIterationCount &amp;&amp; passIterationCount &lt; maxIterationCount) {
            /**
                  * The event is fired when an iteration of an animation ends.
                  * @event Animator#iteration
                  * @param {Object} param The object of data to be sent to an event.
                  * @param {Number} param.currentTime The total time that the animator is running.
                  * @param {Number} param.iterationCount The iteration count that the animator is running.
                  */
            this.trigger("iteration", {
                currentTime: state[CURRENT_TIME],
                iterationCount: passIterationCount,
            });
        }
        state[ITERATION] = iterationCount;
        return this;
    }
    protected calculate() {
        const state = this.state;
        const iterationCount = state[ITERATION_COUNT];
        const fillMode = state[FILL_MODE];
        const direction = state[DIRECTION];
        const duration = this.getDuration();
        const time = this.getTime();
        const iteration = duration === 0 ? 0 : time / duration;
        let currentIterationTime = duration ? time % duration : 0;

        if (!duration) {
            this.setIterationTime(0);
            return this;
        }
        this.setIteration(iteration);

        // direction : normal, reverse, alternate, alternate-reverse
        // fillMode : forwards, backwards, both, none
        const isReverse = isDirectionReverse(iteration, iterationCount, direction);

        const isFiniteDuration = isFinite(duration);
        if (isFiniteDuration &amp;&amp; isReverse) {
            currentIterationTime = duration - currentIterationTime;
        }
        if (isFiniteDuration &amp;&amp; iterationCount !== INFINITE) {
            const isForwards = fillMode === "both" || fillMode === "forwards";

            // fill forwards
            if (iteration >= iterationCount) {
                currentIterationTime = duration * (isForwards ? (iterationCount % 1) || 1 : 0);
                isReverse &amp;&amp; (currentIterationTime = duration - currentIterationTime);
            }
        }
        this.setIterationTime(currentIterationTime);
        return this;
    }
    private tick(now: number, to?: number) {
        if (this.isPaused()) {
            return;
        }
        const state = this.state;
        const playSpeed = state[PLAY_SPEED];
        const prevTime = state[PREV_TIME];
        const delay = state[DELAY];
        const tickTime = state[TICK_TIME];
        const currentTime = tickTime + Math.min(1000, now - prevTime) / 1000 * playSpeed;

        state[PREV_TIME] = now;
        this.setTime(currentTime - delay, true);
        if (to &amp;&amp; to * 1000 &lt; now) {
            this.pause();
        }
        if (state[PLAY_STATE] === PAUSED) {
            return;
        }

        this.timerId = requestAnimationFrame((time: number) => {
            this.tick(time, to);
        });
    }
}
/**
 * Specifies the unique indicator of the animator
 * @method Animator#setId
 * @param {number | string} - String or number of id to be set in the animator
 * @return {Animator} An instance itself.
 */
/**
 * Specifies the unique indicator of the animator
 * @method Animator#getId
 * @return {number | string} the indicator of the item.
 */
/**
 * Get a delay for the start of an animation.
 * @method Animator#getDelay
 * @return {number} delay
 */
/**
 * Set a delay for the start of an animation.
 * @method Animator#setDelay
 * @param {number} delay - delay
 * @return {Animator} An instance itself.
 */
/**
 * Get fill mode for the item when the animation is not playing (before it starts, after it ends, or both)
 * @method Animator#getFillMode
 * @return {FillModeType} fillMode
 */
/**
 * Set fill mode for the item when the animation is not playing (before it starts, after it ends, or both)
 * @method Animator#setFillMode
 * @param {FillModeType} fillMode - fillMode
 * @return {Animator} An instance itself.
 */
/**
 * Get the number of times an animation should be played.
 * @method Animator#getIterationCount
 * @return {IterationCountType} iterationCount
 */
/**
 * Set the number of times an animation should be played.
 * @method Animator#setIterationCount
 * @param {IterationCountType} iterationCount - iterationCount
 * @return {Animator} An instance itself.
 */
/**
 * Get whether an animation should be played forwards, backwards or in alternate cycles.
 * @method Animator#getDirection
 * @return {DirectionType} direction
 */
/**
 * Set whether an animation should be played forwards, backwards or in alternate cycles.
 * @method Animator#setDirection
 * @param {DirectionType} direction - direction
 * @return {Animator} An instance itself.
 */
/**
 * Get whether the animation is running or paused.
 * @method Animator#getPlayState
 * @return {PlayStateType} playState
 */
/**
 * Set whether the animation is running or paused.
 * @method Animator#setPlayState
 * @param {PlayStateType} playState - playState
 * @return {Animator} An instance itself.
 */
/**
 * Get the animator's play speed
 * @method Animator#getPlaySpeed
 * @return {number} playSpeed
 */
/**
 * Set the animator's play speed
 * @method Animator#setPlaySpeed
 * @param {number} playSpeed - playSpeed
 * @return {Animator} An instance itself.
 */
/**
 * Get how long an animation should take to complete one cycle.
 * @method Animator#getDuration
 * @return {number} duration
 */
/**
 * Set how long an animation should take to complete one cycle.
 * @method Animator#setDuration
 * @param {number} duration - duration
 * @return {Animator} An instance itself.
 */
/**
 * Get the speed curve of an animation.
 * @method Animator#getEasing
 * @return {EasingType} easing
 */
/**
 * Get the speed curve's name
 * @method Animator#getEasingName
 * @return {string} the curve's name.
 */
/**
	* Get the animator's current iteration time
	* @method Animator#getIterationTime
	* @return {number} current iteration time
	* @example
animator.getIterationTime();
	*/

// tslint:disable-next-line:interface-name
interface Animator&lt;T extends AnimatorOptions = AnimatorOptions, U extends AnimatorState = AnimatorState> {
    setId(id: number | string): this;
    getId(): number | string;
    getIterationTime(): number;
    setIterationTime(time: number): this;
    setDelay(delay: number): this;
    getDelay(): number;
    setFillMode(fillMode: FillModeType): this;
    getFillMode(): FillModeType;
    setIterationCount(iterationCount: IterationCountType): this;
    getIterationCount(): IterationCountType;
    setDirection(direction: DirectionType): this;
    getDirection(): DirectionType;
    setPlayState(playState: PlayStateType): this;
    getPlayState(): PlayStateType;
    setPlaySpeed(playSpeed: number): this;
    getPlaySpeed(): number;
    setDuration(duration: number): this;
    getDuration(): number;
    getEasing(): EasingType;
    getEasingName(): string;
}
export default Animator;
</code></pre>
        </article>
    </section>





<style>


nav li[file="animator"]:after {
    display: none;
}
nav li[file="animator"] h4, nav li[file="animator"] ul {
    display: block;
}
</style>

</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/daybrush/jsdoc">JSDoc 0.3.7</a> on Fri May 31 2019 02:27:27 GMT+0900 (GMT+09:00) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/utils.min.js"></script>
<script src="scripts/search.js"></script>
<script src="scripts/custom.js"></script>
</body>
</html>
